name: Deploy Blog

on:
  push:
    branches: [main]
    paths:
      - 'Posts/**'
      - 'Pipeline/**'
      - '.github/workflows/**'
      - 'CUSTOM_DOMAIN_SETUP.md'
      - 'AGENTS.md'
      - 'README.md'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Deployment mode'
        required: true
        default: 'stage'
        type: choice
        options:
          - stage
          - production

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      changed-files: ${{ steps.changes.outputs.posts }}
      deployment-mode: ${{ steps.mode.outputs.mode }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history to detect first commit
      
      - name: Determine deployment mode
        id: mode
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            MODE="${{ github.event.inputs.mode }}"
          else
            # Default to staging for automatic pushes
            MODE="stage"
          fi
          echo "mode=$MODE" >> $GITHUB_OUTPUT
          echo "Deployment mode: $MODE"
      
      - name: Detect changed posts
        id: changes
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Checking for posts in Posts/ directory..."
          ls -la Posts/ || echo "Posts directory not found"
          
          # Always find all posts - we copy all posts to build anyway
          # This ensures metadata changes (like published flag) are always detected
          POSTS=$(find Posts -name "*.md" -type f 2>/dev/null | tr '\n' ' ')
          
          if [ -z "$POSTS" ]; then
            echo "No posts found in Posts/ directory"
            echo "posts=" >> $GITHUB_OUTPUT
          else
            echo "Found posts: $POSTS"
            echo "posts=$POSTS" >> $GITHUB_OUTPUT
          fi
  
  process-posts:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.changed-files != ''
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install script dependencies
        run: |
          cd Pipeline/scripts
          npm install
      
      - name: Process posts
        id: process
        run: |
          cd Pipeline/scripts
          POSTS="${{ needs.detect-changes.outputs.changed-files }}"
          
          for post in $POSTS; do
            echo "Processing: $post"
            node process-post.js "../../$post" || exit 1
          done
          
          echo "All posts processed successfully"
  
  publish-to-platforms:
    needs: [detect-changes, process-posts]
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.changed-files != ''
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install script dependencies
        run: |
          cd Pipeline/scripts
          npm install
      
      - name: Publish to platforms
        env:
          MEDIUM_TOKEN: ${{ secrets.MEDIUM_TOKEN }}
          DEVTO_API_KEY: ${{ secrets.DEVTO_API_KEY }}
          LINKEDIN_ACCESS_TOKEN: ${{ secrets.LINKEDIN_ACCESS_TOKEN }}
          LINKEDIN_ORG_ID: ${{ secrets.LINKEDIN_ORG_ID }}
          DRAFT_MODE: ${{ needs.detect-changes.outputs.deployment-mode == 'stage' && 'true' || 'false' }}
          METADATA_FILE: ${{ github.workspace }}/../Local/.local/metadata.json
        run: |
          cd Pipeline/scripts
          POSTS="${{ needs.detect-changes.outputs.changed-files }}"
          MODE="${{ needs.detect-changes.outputs.deployment-mode }}"
          
          # Create metadata directory
          mkdir -p ../../.local
          
          for post in $POSTS; do
            echo "Publishing: $post (mode: $MODE)"
            node publish-all.js "../../$post" || echo "Failed to publish $post, continuing..."
          done
      
      - name: Upload metadata
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: publish-metadata
          path: .local/metadata.json
          if-no-files-found: ignore
  
  build-site:
    needs: [detect-changes]
    runs-on: ubuntu-latest
    # Always build when workflow is triggered
    # The workflow only triggers on Posts/** or Pipeline/** changes, so we should always build
    # This ensures published flag changes and other metadata updates trigger a full rebuild
    # We copy ALL posts anyway, so we need to rebuild whenever Posts/ changes
    # Note: Can run in parallel with publish-to-platforms (process-posts is optional)
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Copy posts to Astro content directory
        run: |
          mkdir -p Pipeline/site/src/content/blog
          mkdir -p Pipeline/site/public/Images
          
          # Clear existing posts to ensure fresh copy (remove stale files)
          echo "Clearing existing posts from Astro content directory..."
          rm -f Pipeline/site/src/content/blog/*.md
          
          # Copy ALL posts (force overwrite) - this ensures published flag changes are included
          echo "Copying ALL posts from Posts/ to Astro content directory..."
          echo "This ensures any published flag changes or metadata updates are included in the build"
          cp -v Posts/*.md Pipeline/site/src/content/blog/ || true
          
          # Verify copy succeeded
          echo "Verifying copied posts:"
          ls -la Pipeline/site/src/content/blog/*.md || echo "WARNING: No posts found after copy!"
          echo "Post count: $(ls -1 Pipeline/site/src/content/blog/*.md 2>/dev/null | wc -l)"
          
          # Verify specific post was copied correctly (for debugging)
          if [ -f "Posts/blog_post_5.md" ] && [ -f "Pipeline/site/src/content/blog/blog_post_5.md" ]; then
            echo "Verifying blog_post_5.md was copied correctly:"
            SOURCE_SIZE=$(wc -c < "Posts/blog_post_5.md")
            DEST_SIZE=$(wc -c < "Pipeline/site/src/content/blog/blog_post_5.md")
            echo "Source size: $SOURCE_SIZE bytes, Destination size: $DEST_SIZE bytes"
            if [ "$SOURCE_SIZE" != "$DEST_SIZE" ]; then
              echo "WARNING: File sizes don't match! Copy may have failed."
            else
              echo "✓ File sizes match - copy successful"
            fi
          fi
          
          # Copy images (with verification)
          if [ -d "Images" ] && [ "$(ls -A Images 2>/dev/null)" ]; then
            echo "Copying images from Images/ to Pipeline/site/public/Images/"
            cp -r Images/* Pipeline/site/public/Images/ || true
            echo "Images copied. Contents of public/Images:"
            ls -la Pipeline/site/public/Images/ | head -10
          else
            echo "WARNING: Images directory is empty or doesn't exist"
          fi
          
          # Normalize frontmatter (convert Date objects to strings for Astro)
          cd Pipeline/scripts
          npm install
          for post in ../../site/src/content/blog/*.md; do
            if [ -f "$post" ]; then
              node normalize-frontmatter.js "$post"
            fi
          done
          cd ../..
          
          # Generate CNAME file from config (create directory first)
          mkdir -p Pipeline/site/public
          cd Pipeline/scripts
          BLOG_DOMAIN="${{ secrets.BLOG_DOMAIN || 'blog.YOUR_DOMAIN.com' }}" \
          GITHUB_USERNAME="${{ secrets.GITHUB_USERNAME || 'YOUR_GITHUB_USERNAME' }}" \
          node generate-cname.js ../../site/public/CNAME
          cd ../..
          
          # Fix image paths in markdown files
          # Determine base path for image URLs (matches ASTRO_BASE_PATH logic)
          if [ -n "${{ secrets.BLOG_DOMAIN }}" ] && [[ "${{ secrets.BLOG_DOMAIN }}" != *"github.io"* ]] && [[ "${{ secrets.BLOG_DOMAIN }}" != "blog.YOUR_DOMAIN.com" ]]; then
            IMAGE_BASE_PATH="/"
            echo "Using custom domain, image base: /"
          else
            IMAGE_BASE_PATH="/ModernBlog/"
            echo "Using GitHub Pages subdirectory, image base: /ModernBlog/"
          fi
          echo "Converting relative image paths (../Images/ -> Images/)..."
          # Convert relative paths to base-relative paths (no leading slash, no base prefix)
          find Pipeline/site/src/content/blog -name "*.md" -exec sed -i "s|../Images/|Images/|g" {} \;
          echo "Image paths converted. Sample content:"
          grep -h "src=" Pipeline/site/src/content/blog/*.md | head -3 || echo "No image tags found"
      
      - name: Install Astro dependencies
        run: |
          cd Pipeline/site
          npm install
      
      - name: Build Astro site
        run: |
          cd Pipeline/site
          # Set base path: /ModernBlog/ for GitHub Pages subdirectory, / for custom domain
          # If BLOG_DOMAIN is set to a custom domain, use /, otherwise use /ModernBlog/
          if [ -n "${{ secrets.BLOG_DOMAIN }}" ] && [[ "${{ secrets.BLOG_DOMAIN }}" != *"github.io"* ]] && [[ "${{ secrets.BLOG_DOMAIN }}" != "blog.YOUR_DOMAIN.com" ]]; then
            export ASTRO_BASE_PATH="/"
            echo "Using custom domain, base path: /"
          else
            export ASTRO_BASE_PATH="/ModernBlog/"
            echo "Using GitHub Pages subdirectory, base path: /ModernBlog/"
          fi
          echo "Building with ASTRO_BASE_PATH: $ASTRO_BASE_PATH"
          npm run build
          # Check where build output went
          if [ -d "../build" ]; then
            echo "Build completed to ../build"
          elif [ -d "dist" ]; then
            echo "Build went to dist/, moving to ../build"
            mkdir -p ../build
            mv dist/* ../build/
            rmdir dist
          else
            echo "ERROR: Build output not found in ../build or dist/"
            exit 1
          fi
          # NO POST-BUILD PATH FIXING - Astro handles paths correctly
          # The issue was double-prefixing from this sed command
          # Verify images are in build output
          echo "Checking for images in build output:"
          if [ -d "../build/Images" ]; then
            echo "✓ Images directory found in build output"
            ls -la ../build/Images/ | head -10
          else
            echo "WARNING: Images directory not found in build output!"
            echo "Contents of build root:"
            ls -la ../build/ | head -10
          fi
      
      - name: Create .nojekyll file
        run: |
          # Ensure build directory exists
          mkdir -p Pipeline/build
          touch Pipeline/build/.nojekyll
          echo "Created .nojekyll to disable Jekyll processing"
      
      - name: Verify build output
        run: |
          echo "Checking build output directory..."
          if [ ! -d "Pipeline/build" ]; then
            echo "ERROR: Build directory does not exist!"
            exit 1
          fi
          echo "Build directory exists. Contents:"
          ls -la Pipeline/build/ | head -20
          echo "Total files:"
          find Pipeline/build -type f | wc -l
          if [ ! -f "Pipeline/build/index.html" ]; then
            echo "WARNING: index.html not found in build output!"
          else
            echo "✓ index.html found"
          fi
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: site-build
          path: Pipeline/build/**
          retention-days: 7
          if-no-files-found: error
  
  deploy-github-pages:
    needs: build-site
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: site-build
          path: ./build-output
      
      - name: Prepare pages build
        run: |
          # Artifact preserves directory structure, so files are at ./build-output/Pipeline/build
          # Copy to a clean directory for Pages deployment
          mkdir -p ./pages-build
          if [ -d "./build-output/Pipeline/build" ]; then
            cp -r ./build-output/Pipeline/build/* ./pages-build/
          elif [ -d "./build-output" ]; then
            # Fallback: check if files are directly in build-output
            cp -r ./build-output/* ./pages-build/ 2>/dev/null || true
          else
            echo "ERROR: Could not find build artifacts!"
            echo "Contents of build-output:"
            ls -la ./build-output/ || echo "build-output doesn't exist"
            exit 1
          fi
          echo "Prepared pages build. Contents:"
          ls -la ./pages-build/ | head -10
          if [ ! -f "./pages-build/index.html" ]; then
            echo "WARNING: index.html not found in pages-build!"
          else
            echo "✓ index.html found"
          fi
          # Verify images are in pages build
          if [ -d "./pages-build/Images" ]; then
            echo "✓ Images directory found in pages-build"
            ls -la ./pages-build/Images/ | head -10
          else
            echo "WARNING: Images directory not found in pages-build!"
            echo "This may cause broken image links on the live site."
          fi
      
      - name: Setup Pages
        uses: actions/configure-pages@v4
      
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: ./pages-build
      
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
  
  deploy-vercel:
    needs: build-site
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.deployment-mode == 'production'
    continue-on-error: true
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: site-build
      
      - name: Install Vercel CLI
        run: npm install -g vercel@latest
      
      - name: Deploy to Vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          cd Pipeline/build
          vercel --prod --token $VERCEL_TOKEN --yes
